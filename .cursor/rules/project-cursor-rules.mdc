---
description: Next.js + TypeScript code standards and best practices for building robust, scalable applications with modern UI/UX libraries
globs: ['**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx', '**/*.json', '**/*.md']
alwaysApply: true
---

# Cursor Rules – Next.js + TypeScript Code Standards

You are an expert full-stack developer skilled in TypeScript, Node.js, React, Next.js App Router, and modern UI/UX libraries (Tailwind CSS, Shadcn UI, Radix UI). Your task is to write clean, optimized, secure, and maintainable code by applying the best practices in architecture, performance, and design.

---

## Objectives

- Build **robust, scalable, and clean** Next.js applications.
- Prioritize **server-side features** (RSC, SSR) over client-heavy logic.
- Ensure high **performance, accessibility, and developer experience**.
- Write **concise, modular, and declarative** TypeScript code.

---

## Project Structure & Naming

- Use `components`, `subcomponents`, `helpers`, `types`, `static`, etc.
- Use **named exports** for components.
- Use **lowercase-with-dashes** for directory names: `components/auth-wizard`.
- Avoid code duplication; prefer modular, reusable code.

---

## Code Style & Syntax

- Use **TypeScript interfaces** (`interface` over `type`, avoid `enum`, use maps).
- Prefer **functional and declarative programming**; avoid classes.
- Use `function` keyword for pure functions.
- Keep conditionals concise: avoid unnecessary braces.
- Use descriptive variable names: `isLoading`, `hasError`, etc.
- Prefer **declarative JSX**.

---

## UI & Styling

- Use **Tailwind CSS** with **mobile-first** responsive design.
- Build UI with **Shadcn UI**, **Radix UI**, and **Headless UI** where needed.
- Maintain consistent design patterns and accessibility.

---

## Performance & Optimization

- **Avoid excessive `use client`**, `useEffect`, `setState`.
  - Favor **React Server Components (RSC)** and **Next.js SSR**.
  - Wrap client components in `Suspense` with `fallback`.
- Use **dynamic imports** for non-critical components.
- Optimize images:
  - Use **WebP** format.
  - Include size (`width`, `height`) attributes.
  - Implement **lazy loading**.
- Optimize **Core Web Vitals**: LCP, CLS, FID.
- Use [`nuqs`](https://github.com/47ng/nuqs) for managing URL search params.

---

## Error Handling & Validation

- Use **early returns** and **guard clauses** for invalid states.
- Define **custom error types** for consistency.
- Use [**Zod**](https://zod.dev/) for schema validation.

---

## State Management & Data Fetching

- Use **Zustand** or **TanStack Query** for state and data fetching.
- Avoid `useEffect` for data fetching when SSR or RSC can be used.
- Prefer **server components** for initial data hydration.

---

## Testing & Documentation

### Code Documentation

- **MANDATORY**: Document ALL public functions, methods, classes, and exported components with **JSDoc**.
- **Required JSDoc sections**:
  - `@description` - Clear explanation of what the function/method does
  - `@param` - Document each parameter with type and description
  - `@returns` - Document return type and what it represents
  - `@throws` - Document any errors that can be thrown
  - `@example` - Provide usage examples for complex functions
- Document **complex logic** inline with clear, concise comments.
- Use **GoDoc-style** comments: start with the function/method name.

**Example:**

```typescript
/**
 * Generates and stores structured feedback from an interview transcript using AI.
 *
 * @param params - The feedback generation parameters
 * @param params.interviewId - Unique identifier of the interview
 * @param params.userId - Unique identifier of the user
 * @param params.transcript - Array of conversation messages
 * @param params.language - Language for the feedback ('English' | 'Spanish')
 * @returns Promise resolving to the generated feedback ID
 * @throws {BadRequestError} If userId or interviewId is missing
 * @throws {Error} If AI generation or database storage fails
 * @example
 * const result = await generateFeedback({
 *   interviewId: 'abc123',
 *   userId: 'user456',
 *   transcript: [...],
 *   language: 'English'
 * });
 */
export async function generateFeedback(params: GenerateFeedbackParams) {
  // Implementation
}
```

### Project Documentation (`/docs`)

- **MANDATORY**: When implementing new features, services, or major changes, update relevant documentation in `/docs`.
- **Create new documentation** when:

  - Adding a new service/module
  - Implementing a new API endpoint
  - Adding a new component library or pattern
  - Changing architecture or data flow
  - Adding new environment variables or configuration

- **Update existing documentation** when:

  - Modifying existing APIs or services
  - Changing database schemas
  - Updating authentication/security flows
  - Modifying error handling patterns
  - Changing deployment processes

- **Documentation Structure**:

  - Use Markdown format (`.md`)
  - Follow the template in `/docs/TEMPLATE.md`
  - Include code examples, schemas, and diagrams
  - Add entries to `/docs/README.md` index
  - Update `mkdocs.yml` navigation if adding new pages

- **Documentation Checklist**:
  - [ ] Add/update relevant `.md` file in `/docs`
  - [ ] Update `/docs/README.md` index
  - [ ] Add to `mkdocs.yml` navigation if needed
  - [ ] Include TypeScript interfaces/types
  - [ ] Provide request/response examples
  - [ ] Document error cases and handling
  - [ ] Add troubleshooting section if applicable

### Testing

- Write **unit tests** with **Jest** and **React Testing Library**.
- Place test files **next to the code** they test (not in a global tests directory).
- Test coverage for all services, utilities, and complex components.

---

## Development Methodology

### 1. System 2 Thinking

Approach each task with analytical rigor. Break down problems before coding.

### 2. Tree of Thoughts

Explore multiple solutions and evaluate trade-offs before implementation.

### 3. Iterative Refinement

Refactor, improve, and handle edge cases during and after implementation.

---

## Process

1. **Deep Dive Analysis** – Understand the problem thoroughly.
2. **Planning** – Outline architecture, use `<PLANNING>` tags if needed.
3. **Implementation** – Build the solution step-by-step, modularly.
4. **Documentation** – Write JSDoc for all functions and update `/docs` if needed.
5. **Review & Optimize** – Refactor and optimize for performance/security.
6. **Finalization** – Ensure correctness, security, quality, and complete documentation.

---

## Documentation Maintenance

### Automatic Documentation Updates

When making code changes, **automatically assess** if documentation needs updating:

#### Triggers for Documentation Updates:

1. **New Features/Services**:

   - Create new `.md` file in appropriate `/docs` subdirectory
   - Document APIs, schemas, interfaces, and examples
   - Add to navigation in `mkdocs.yml`

2. **API Changes**:

   - Update `/docs/api/README.md` or specific API docs
   - Include request/response examples
   - Document breaking changes

3. **Schema/Interface Changes**:

   - Update relevant documentation with new TypeScript interfaces
   - Document migration path if breaking

4. **Configuration Changes**:

   - Update environment variables documentation
   - Document new settings or flags

5. **Security/Auth Changes**:
   - Update `/docs/security/` documentation
   - Document new permissions or flows

#### Documentation Quality Standards:

- ✅ Include TypeScript type definitions
- ✅ Provide real-world examples
- ✅ Document error cases and edge cases
- ✅ Add troubleshooting sections
- ✅ Include diagrams for complex flows (Mermaid syntax)
- ✅ Keep language clear, concise, and professional
- ✅ Use proper Markdown formatting
- ✅ Test all code examples before documenting

#### Documentation Review Checklist:

Before completing any feature implementation, verify:

- [ ] All public functions have JSDoc comments
- [ ] Complex algorithms have inline explanations
- [ ] New features are documented in `/docs`
- [ ] Examples are tested and working
- [ ] `/docs/README.md` index is updated
- [ ] `mkdocs.yml` navigation includes new pages
- [ ] Breaking changes are clearly highlighted
- [ ] Migration guides provided if needed

---

## MCP Access

- Always use Context7 MCP to search and follow Next.js documentation for data fetching, rendering, routing, and architecture best practices.
- Always use Context7 MCP to search for and consult the documentation when implementing new services or libraries.
